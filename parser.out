Grammar:

Rule 0     S' -> program
Rule 1     program -> expr
Rule 2     program -> INT MAIN LPAREN RPAREN LCB stmt_list return_stmt RCB
Rule 3     stmt_list -> stmt
Rule 4     stmt_list -> stmt stmt_list
Rule 5     stmt -> LPAREN expr RPAREN
Rule 6     stmt -> INT ID ASSIGN expr SEMI
Rule 7     return_stmt -> RETURN factor SEMI
Rule 8     expr -> factor
Rule 9     expr -> factor / expr  [precedence=left, level=2]
Rule 10    expr -> factor * expr  [precedence=left, level=2]
Rule 11    expr -> factor - expr  [precedence=left, level=1]
Rule 12    expr -> factor + expr  [precedence=left, level=1]
Rule 13    factor -> ID
Rule 14    factor -> NUM

Unused terminals:

    FLOAT
    VOID
    BREAK
    SIZEOF
    BOOL
    DOUBLE
    WHILE
    EQREL
    NOTEQ
    INCRMNT
    LESEQ
    STRUCT
    UNSIGNED
    DECREMNT
    ENUM
    IMAGINARY
    DEFAULT
    FOR
    SHORT
    GRTEQ
    INLINE
    NEGATE
    LONG
    SWITCH
    COMPLEX
    VOLATILE
    CHAR
    EXTERN
    CONST
    DO
    IF
    LOGICAND
    ELSE
    REGISTER
    SIGNED
    CONTINUE
    LTR
    AUTO
    CASE
    GOTO
    TYPEDEF
    UNION
    STATIC
    GTR
    LOGICOR

Terminals, with rules where they appear:

*                    : 10
+                    : 12
-                    : 11
/                    : 9
ASSIGN               : 6
AUTO                 : 
BOOL                 : 
BREAK                : 
CASE                 : 
CHAR                 : 
COMPLEX              : 
CONST                : 
CONTINUE             : 
DECREMNT             : 
DEFAULT              : 
DO                   : 
DOUBLE               : 
ELSE                 : 
ENUM                 : 
EQREL                : 
EXTERN               : 
FLOAT                : 
FOR                  : 
GOTO                 : 
GRTEQ                : 
GTR                  : 
ID                   : 6 13
IF                   : 
IMAGINARY            : 
INCRMNT              : 
INLINE               : 
INT                  : 2 6
LCB                  : 2
LESEQ                : 
LOGICAND             : 
LOGICOR              : 
LONG                 : 
LPAREN               : 2 5
LTR                  : 
MAIN                 : 2
NEGATE               : 
NOTEQ                : 
NUM                  : 14
RCB                  : 2
REGISTER             : 
RETURN               : 7
RPAREN               : 2 5
SEMI                 : 6 7
SHORT                : 
SIGNED               : 
SIZEOF               : 
STATIC               : 
STRUCT               : 
SWITCH               : 
TYPEDEF              : 
UNION                : 
UNSIGNED             : 
VOID                 : 
VOLATILE             : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear:

expr                 : 1 5 6 9 10 11 12
factor               : 7 8 9 10 11 12
program              : 0
return_stmt          : 2
stmt                 : 3 4
stmt_list            : 2 4


state 0

    (0) S' -> . program
    (1) program -> . expr
    (2) program -> . INT MAIN LPAREN RPAREN LCB stmt_list return_stmt RCB
    (8) expr -> . factor
    (9) expr -> . factor / expr
    (10) expr -> . factor * expr
    (11) expr -> . factor - expr
    (12) expr -> . factor + expr
    (13) factor -> . ID
    (14) factor -> . NUM
    INT             shift and go to state 3
    ID              shift and go to state 5
    NUM             shift and go to state 6

    program                        shift and go to state 1
    expr                           shift and go to state 2
    factor                         shift and go to state 4

state 1

    (0) S' -> program .


state 2

    (1) program -> expr .
    $end            reduce using rule 1 (program -> expr .)


state 3

    (2) program -> INT . MAIN LPAREN RPAREN LCB stmt_list return_stmt RCB
    MAIN            shift and go to state 7


state 4

    (8) expr -> factor .
    (9) expr -> factor . / expr
    (10) expr -> factor . * expr
    (11) expr -> factor . - expr
    (12) expr -> factor . + expr
    $end            reduce using rule 8 (expr -> factor .)
    RPAREN          reduce using rule 8 (expr -> factor .)
    SEMI            reduce using rule 8 (expr -> factor .)
    /               shift and go to state 8
    *               shift and go to state 9
    -               shift and go to state 10
    +               shift and go to state 11


state 5

    (13) factor -> ID .
    /               reduce using rule 13 (factor -> ID .)
    *               reduce using rule 13 (factor -> ID .)
    -               reduce using rule 13 (factor -> ID .)
    +               reduce using rule 13 (factor -> ID .)
    $end            reduce using rule 13 (factor -> ID .)
    RPAREN          reduce using rule 13 (factor -> ID .)
    SEMI            reduce using rule 13 (factor -> ID .)


state 6

    (14) factor -> NUM .
    /               reduce using rule 14 (factor -> NUM .)
    *               reduce using rule 14 (factor -> NUM .)
    -               reduce using rule 14 (factor -> NUM .)
    +               reduce using rule 14 (factor -> NUM .)
    $end            reduce using rule 14 (factor -> NUM .)
    RPAREN          reduce using rule 14 (factor -> NUM .)
    SEMI            reduce using rule 14 (factor -> NUM .)


state 7

    (2) program -> INT MAIN . LPAREN RPAREN LCB stmt_list return_stmt RCB
    LPAREN          shift and go to state 12


state 8

    (9) expr -> factor / . expr
    (8) expr -> . factor
    (9) expr -> . factor / expr
    (10) expr -> . factor * expr
    (11) expr -> . factor - expr
    (12) expr -> . factor + expr
    (13) factor -> . ID
    (14) factor -> . NUM
    ID              shift and go to state 5
    NUM             shift and go to state 6

    factor                         shift and go to state 4
    expr                           shift and go to state 13

state 9

    (10) expr -> factor * . expr
    (8) expr -> . factor
    (9) expr -> . factor / expr
    (10) expr -> . factor * expr
    (11) expr -> . factor - expr
    (12) expr -> . factor + expr
    (13) factor -> . ID
    (14) factor -> . NUM
    ID              shift and go to state 5
    NUM             shift and go to state 6

    factor                         shift and go to state 4
    expr                           shift and go to state 14

state 10

    (11) expr -> factor - . expr
    (8) expr -> . factor
    (9) expr -> . factor / expr
    (10) expr -> . factor * expr
    (11) expr -> . factor - expr
    (12) expr -> . factor + expr
    (13) factor -> . ID
    (14) factor -> . NUM
    ID              shift and go to state 5
    NUM             shift and go to state 6

    factor                         shift and go to state 4
    expr                           shift and go to state 15

state 11

    (12) expr -> factor + . expr
    (8) expr -> . factor
    (9) expr -> . factor / expr
    (10) expr -> . factor * expr
    (11) expr -> . factor - expr
    (12) expr -> . factor + expr
    (13) factor -> . ID
    (14) factor -> . NUM
    ID              shift and go to state 5
    NUM             shift and go to state 6

    factor                         shift and go to state 4
    expr                           shift and go to state 16

state 12

    (2) program -> INT MAIN LPAREN . RPAREN LCB stmt_list return_stmt RCB
    RPAREN          shift and go to state 17


state 13

    (9) expr -> factor / expr .
    $end            reduce using rule 9 (expr -> factor / expr .)
    RPAREN          reduce using rule 9 (expr -> factor / expr .)
    SEMI            reduce using rule 9 (expr -> factor / expr .)


state 14

    (10) expr -> factor * expr .
    $end            reduce using rule 10 (expr -> factor * expr .)
    RPAREN          reduce using rule 10 (expr -> factor * expr .)
    SEMI            reduce using rule 10 (expr -> factor * expr .)


state 15

    (11) expr -> factor - expr .
    $end            reduce using rule 11 (expr -> factor - expr .)
    RPAREN          reduce using rule 11 (expr -> factor - expr .)
    SEMI            reduce using rule 11 (expr -> factor - expr .)


state 16

    (12) expr -> factor + expr .
    $end            reduce using rule 12 (expr -> factor + expr .)
    RPAREN          reduce using rule 12 (expr -> factor + expr .)
    SEMI            reduce using rule 12 (expr -> factor + expr .)


state 17

    (2) program -> INT MAIN LPAREN RPAREN . LCB stmt_list return_stmt RCB
    LCB             shift and go to state 18


state 18

    (2) program -> INT MAIN LPAREN RPAREN LCB . stmt_list return_stmt RCB
    (3) stmt_list -> . stmt
    (4) stmt_list -> . stmt stmt_list
    (5) stmt -> . LPAREN expr RPAREN
    (6) stmt -> . INT ID ASSIGN expr SEMI
    LPAREN          shift and go to state 20
    INT             shift and go to state 19

    stmt_list                      shift and go to state 21
    stmt                           shift and go to state 22

state 19

    (6) stmt -> INT . ID ASSIGN expr SEMI
    ID              shift and go to state 23


state 20

    (5) stmt -> LPAREN . expr RPAREN
    (8) expr -> . factor
    (9) expr -> . factor / expr
    (10) expr -> . factor * expr
    (11) expr -> . factor - expr
    (12) expr -> . factor + expr
    (13) factor -> . ID
    (14) factor -> . NUM
    ID              shift and go to state 5
    NUM             shift and go to state 6

    expr                           shift and go to state 24
    factor                         shift and go to state 4

state 21

    (2) program -> INT MAIN LPAREN RPAREN LCB stmt_list . return_stmt RCB
    (7) return_stmt -> . RETURN factor SEMI
    RETURN          shift and go to state 26

    return_stmt                    shift and go to state 25

state 22

    (3) stmt_list -> stmt .
    (4) stmt_list -> stmt . stmt_list
    (3) stmt_list -> . stmt
    (4) stmt_list -> . stmt stmt_list
    (5) stmt -> . LPAREN expr RPAREN
    (6) stmt -> . INT ID ASSIGN expr SEMI
    RETURN          reduce using rule 3 (stmt_list -> stmt .)
    LPAREN          shift and go to state 20
    INT             shift and go to state 19

    stmt                           shift and go to state 22
    stmt_list                      shift and go to state 27

state 23

    (6) stmt -> INT ID . ASSIGN expr SEMI
    ASSIGN          shift and go to state 28


state 24

    (5) stmt -> LPAREN expr . RPAREN
    RPAREN          shift and go to state 29


state 25

    (2) program -> INT MAIN LPAREN RPAREN LCB stmt_list return_stmt . RCB
    RCB             shift and go to state 30


state 26

    (7) return_stmt -> RETURN . factor SEMI
    (13) factor -> . ID
    (14) factor -> . NUM
    ID              shift and go to state 5
    NUM             shift and go to state 6

    factor                         shift and go to state 31

state 27

    (4) stmt_list -> stmt stmt_list .
    RETURN          reduce using rule 4 (stmt_list -> stmt stmt_list .)


state 28

    (6) stmt -> INT ID ASSIGN . expr SEMI
    (8) expr -> . factor
    (9) expr -> . factor / expr
    (10) expr -> . factor * expr
    (11) expr -> . factor - expr
    (12) expr -> . factor + expr
    (13) factor -> . ID
    (14) factor -> . NUM
    ID              shift and go to state 5
    NUM             shift and go to state 6

    expr                           shift and go to state 32
    factor                         shift and go to state 4

state 29

    (5) stmt -> LPAREN expr RPAREN .
    LPAREN          reduce using rule 5 (stmt -> LPAREN expr RPAREN .)
    INT             reduce using rule 5 (stmt -> LPAREN expr RPAREN .)
    RETURN          reduce using rule 5 (stmt -> LPAREN expr RPAREN .)


state 30

    (2) program -> INT MAIN LPAREN RPAREN LCB stmt_list return_stmt RCB .
    $end            reduce using rule 2 (program -> INT MAIN LPAREN RPAREN LCB stmt_list return_stmt RCB .)


state 31

    (7) return_stmt -> RETURN factor . SEMI
    SEMI            shift and go to state 33


state 32

    (6) stmt -> INT ID ASSIGN expr . SEMI
    SEMI            shift and go to state 34


state 33

    (7) return_stmt -> RETURN factor SEMI .
    RCB             reduce using rule 7 (return_stmt -> RETURN factor SEMI .)


state 34

    (6) stmt -> INT ID ASSIGN expr SEMI .
    LPAREN          reduce using rule 6 (stmt -> INT ID ASSIGN expr SEMI .)
    INT             reduce using rule 6 (stmt -> INT ID ASSIGN expr SEMI .)
    RETURN          reduce using rule 6 (stmt -> INT ID ASSIGN expr SEMI .)
